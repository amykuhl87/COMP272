import java.security.InvalidParameterException;
import java.util.*;
public class MaxHeap<E extends Comparable<E>> extends ArrayList<E>   {

    private ArrayList<E> heap;

    private int parent(int pos){
        return (pos - 1) / 2;
    }

    private int leftChild(int pos){
        return (2 * pos);
    }

    private int rightChild(int pos){
        return (2 * pos) + 1;
    }


    //reference textbook
    private void swap(int fpos, int spos){
        E tmp1, tmp2;
        tmp1 = heap.get(fpos); //gets info at first position
        tmp2 = heap.get(spos); //gets info at second position
        heap.set(fpos, tmp2); //replaces info at first position with info at second position
        heap.set(spos, tmp1); //replaces info at second position with info at first position
    }

    private int largestChild(int parent){
        int index = 0;

        if(heap.get(rightChild(parent)) == null || heap.get(leftChild(parent)) == null){
            index = - 1;
        }

        //if one is there and one is null, return the other

        if (heap.get(rightChild(parent)).compareTo(heap.get(parent)) > 0){
            index = rightChild(parent);
        } else {
            index = leftChild(parent);
        }

        return index;
    }

    // construct an empty Heap using ArrayList
    // with root at index 0.
    // don't use binary tree for implementing the heap.
    public MaxHeap(){
        heap = new ArrayList<E>();
    }
    // returns max value
    public E findMax() {
        return heap.get(0); //largest element is root in a maxHeap
    }

    // adds a new value to the heap at the end of the Heap and 
    // adjusts values up to the root to ensure Max heap property is satisfied.
    // parent of node at i is given by the formula (i-1)/2
    // throw appropriate exception
    public void addHeap(E val) {

        if(!(val instanceof Comparable)){
            throw new InvalidParameterException();
        }

        int index = heap.size(); //place holder

        heap.add(val); //setting val to new spot in array

        while(true){
            if(index == 0) {
                return;
            }
            if(heap.get(index).compareTo(heap.get(parent(index))) > 0){
                swap(index, parent(index));
                index = parent(index);
            } else {
                return;
            }
        }
    }

    //returns the max value at the root of the heap by swapping the last value 
    // and percolating the value down from the root to preserve max heap property
    // children of node at i are given by the formula 2i+1,2i+2, to not exceed the
    // bounds of the Heap index, namely, 0 ... size()-1.
    // throw appropriate exception
    public E removeHeap() {
        E value = heap.get(0);
        heap.set(0, null);
        int index = 0;


        while(true){
            int swapIndex = largestChild(index);
            if(swapIndex == - 1)
                return value;
            //finding largest child
            //moving it up (swapping values)
            swap(index, swapIndex);
            index = swapIndex;
            //repeating process until nothing is left
        }

        //return value;
    }

    // takes a list of items E and builds the heap and then prints 
    // decreasing values of E with calls to removeHeap().  
    public void heapSort(List<E> list){
        boolean done = false;

        //create new heap
        MaxHeap newHeap = new MaxHeap();
        newHeap.buildHeap(list); //building heap

        while (!done) {
            try{
                System.out.print(" " + newHeap.removeHeap());
            } catch (Exception e){
                done = true; //returns done when merge is complete
            }
        }
        //building heap
        //creating output list
    }

    // merges the other maxheap with this maxheap to produce a new maxHeap.  
    public void heapMerge(MaxHeap<E> other){
        MaxHeap newHeap = new MaxHeap();
        boolean done = false;

        while(done == false){
          try{
            newHeap.addHeap(other.removeHeap());
          } catch (Exception e){
              done = true;
          }
        }

    }

    //takes a list of items E and builds the heap by calls to addHeap(..)
    public void buildHeap(List<E> list) {

        for(int i = 0; i < list.size(); i++)
            addHeap(list.get(i));
    }





}
